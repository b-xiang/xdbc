/**
 *  fsysImpl.h
 *
 *  Copyright (C) 2002-2020 zosatapo
 *
 *  zosatapo  dertyang@hotmail.com
 */

#ifndef __OPENCODE_FSYSIMPL_H__
#define __OPENCODE_FSYSIMPL_H__

#include "port/libdefs.h"
#include "port/file.h" 
#include "port/lifetime.h"

__OPENCODE_BEGIN_NAMESPACE

class __OPENCODE_CORE_API_DECL FileSystem 
{
public:
  virtual ~FileSystem() {}

public: 
  /**
   * Convert the given pathname string to normal form.  If the string is
   * already in normal form then it is simply returned.
   */
  virtual string normalize(const string& path) = 0;
  
  /**
   * Compute the length of this pathname string's prefix.  The pathname
   * string must be in normal form.
   */
  virtual int prefixLength(const string& path) = 0;
  
  /**
   * Resolve the child pathname string against the parent.
   * Both strings must be in normal form, and the result
   * will be in normal form.
   */
  virtual string resolve(const string& parent, const string& child) = 0;
  
  /**
   * Return the parent pathname string to be used when the parent-directory
   * argument in one of the two-argument File constructors is the empty
   * pathname.
   */
  virtual string getDefaultParent() = 0;

 /**
  *  return the absolute pathname of current working directory
  */
  virtual   string getCurrentDirectory() = 0;

public:  
  
  /* -- Path operations -- */
  
  /**
   * Tell whether or not the given abstract pathname is absolute.
   */
  virtual bool isAbsolute(const File& f) = 0;
  
  /**
   * Resolve the given abstract pathname into absolute form.  Invoked by the
   * getAbsolutePath and getCanonicalPath methods in the File class.
   */
  virtual string resolve(const File& f) = 0;
  
  virtual string canonicalize(const string& path) __OPENCODE_THROW_DECLARE(IOException) = 0;
  
  /**
   * Check whether the file or directory denoted by the given abstract
   * pathname may be accessed by this process.  If the second argument is
   * <code>false</code>, then a check for read access is made; if the second
   * argument is <code>true</code>, then a check for write (not read-write)
   * access is made.  Return false if access is denied or an I/O error
   * occurs.
   */
  virtual  bool checkAccess(const string& pathname, bool write) = 0;

  /**
   * Return the length in bytes of the file denoted by the given handle
   * , or zero if it does not exist, is a directory, or some other
   * I/O error occurs.
   */
  virtual XLONG getLength(int fd) = 0;

public:    
  /* -- File operations -- */
  
  /**
   * Create a new empty file with the given pathname.  Return
   * <code>true</code> if the file was created and <code>false</code> if a
   * file or directory with the given pathname already exists.  Throw an
   * IOException if an I/O error occurs.
   */
  virtual bool createFileExclusively(const string& pathname,int filemask = 0666) __OPENCODE_THROW_DECLARE(IOException) = 0;
 
  /**
   * List the elements of the directory denoted by the given abstract
   * pathname.  Return true and an array of strings naming the elements of the
   * directory if successful; otherwise, return <code>false</code>.
   */
  virtual bool list(const string& pathname,vector<string>& lists) = 0;
  
  /**
   * Create a new directory denoted by the given abstract pathname,
   * returning <code>true</code> if and only if the operation succeeds.
   */
  virtual bool createDirectory(const string& pathname,int filemask = 0666) = 0;
  
  /**
   * Set the last-modified time of the file or directory denoted by the
   * given abstract pathname, returning <code>true</code> if and only if the
   * operation succeeds.
   */
  virtual bool setLastModifiedTime(const string& pathname, XLONG time) = 0;
  
  /**
   * Mark the file or directory denoted by the given abstract pathname as
   * read-only, returning <code>true</code> if and only if the operation
   * succeeds.
   */
  virtual bool setReadOnly(const string& pathname) = 0;

public:    
  /* -- Filesystem interface -- */
  
  /**
   * List the available filesystem roots.
   */
  virtual bool listRoots(vector<File>& lists) = 0;


  /* -- Temporary files -- */
  
public:  
  /**
  * <p> Creates a new empty file in the specified directory, using the
  * given prefix and suffix strings to generate its name. 
  *
  * <p> To create the new file, the prefix and the suffix may first be
  * adjusted to fit the limitations of the underlying platform.  If the
  * prefix is too long then it will be truncated, but its first three
  * characters will always be preserved.  If the suffix is too long then it
  * too will be truncated, but if it begins with a period character
  * (<code>'.'</code>) then the period and the first three characters
  * following it will always be preserved.  Once these adjustments have been
  * made the name of the new file will be generated by concatenating the
  * prefix, five or more internally-generated characters, and the suffix.
  *
  * <p> If the <code>directory</code> argument is <code>null</code> then the
  * system-dependent default temporary-file directory will be used.  The
  * default temporary-file directory is specified by the system property
  * <code>base.tmpdir</code>.  On UNIX systems the default value of this
  * property is typically <code>"/tmp"</code> or <code>"/var/tmp"</code>; on
  * Microsoft Windows systems it is typically <code>"c:\\temp"</code>.  
  *
  * @param  prefix     The prefix stringto be used in generating the file's
  *                    name; must be at least three characters long
  *
  * @param  suffix     The suffix stringto be used in generating the file's
  *                    name; may be <code>null</code>, in which case the
  *                    suffix <code>".tmp"</code> will be used
  *
  * @param  directory  The directory in which the file is to be created, or
  *                    <code>null</code> if the default temporary-file
  *                    directory is to be used
  *
  * @return  An abstract pathname denoting a newly-created empty file
  *
  *
  * @throws  IOException  If a file could not be created
  */
  virtual  File createTempFile(const string& prefix, const string& suffix,const File* directory) __OPENCODE_THROW_DECLARE(IOException) = 0;
};

class __OPENCODE_CORE_API_DECL GenericFileSystem : public FileSystem
{
  DECLARE_LIFETIME_BEGIN(GenericFileSystem)
  DECLARE_LIFETIME_END(GenericFileSystem)
  
  virtual ~GenericFileSystem() ;
  GenericFileSystem();

public: 
  virtual string normalize(const string& path);
  virtual int    prefixLength(const string& path);
  virtual string resolve(const string& parent, const string& child);
  virtual string getDefaultParent() ;
  virtual string getCurrentDirectory();

  virtual bool   isAbsolute(const File& f);
  virtual string resolve(const File& f);
  virtual string canonicalize(const string& path) __OPENCODE_THROW_DECLARE(IOException) ;
  virtual bool   checkAccess(const string& pathname, bool write);
  virtual XLONG  getLength(int fd);
  virtual bool   setLastModifiedTime(const string& pathname, XLONG time);
  virtual bool   setReadOnly(const string& pathname);
  
  virtual bool   list(const string& pathname,vector<string>& lists);
  virtual bool   listRoots(vector<File>& lists);  
  
  virtual bool   createFileExclusively(const string& pathname,int filemask = 0666) __OPENCODE_THROW_DECLARE(IOException);
  virtual File   createTempFile(const string& prefix, const string& suffix,const File* directory) __OPENCODE_THROW_DECLARE(IOException) ;
  virtual bool   createDirectory(const string& pathname,int filemask = 0666);
};

typedef SingletonHolder<GenericFileSystem,CreateUsingNew<GenericFileSystem>,SingletonWithLongevity<GenericFileSystem>,MultiThread<GenericFileSystem> > FileSystemImpl;
__OPENCODE_INLINE unsigned int getLongevity(GenericFileSystem* impl){return __BASE_LONGEVITY_FS;}

__OPENCODE_END_NAMESPACE

#endif

